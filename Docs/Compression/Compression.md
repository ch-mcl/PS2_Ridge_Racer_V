ヘッダーと圧縮データ群で構成された圧縮ファイル。圧縮方式はLZSS。
解凍時に用いる辞書サイズはファイル毎に指定が可能となっている。
また64個の圧縮データ列毎に圧縮フラグ(8バイト)が現れる。

本ドキュメントにおける参照位置は、コピーを開始するバイト列の位置を示す。
また表におけるindexは展開中のデータのインデックス/添字を指し、dataは実際に展開されているバイト列(16進数表記)そのものを指す。

# TOC
[[_TOC_]]

# フォーマット
ヘッダー

圧縮データ群[]


# ヘッダー
データサイズは10バイト固定。

表1. ヘッダーの構造
| オフセット | データ型 | 詳細 |
|----------|--------|---------------------------------------------------------|
| 0x00     | `byte` | 辞書サイズ指数。2をこの値で累乗すると辞書サイズが求まる。        |
| 0x01     | `byte` | 不明。[^1]                                               |
| 0x02     | `uint` | 解凍後のデータサイズ。                                     |
| 0x06     | `uint` | 解凍前のデータサイズ。0xA ~ EOFまで続く"圧縮データ群"のサイズ。 |

[^1]: "圧縮フラグのバイト数指定"の可能性あり。(要検証。)


# 圧縮データ群

圧縮フラグと圧縮データ列で構成される。

## 圧縮フラグ
データサイズは8バイト。

8つ分の圧縮データ列。

1が圧縮無し、0が圧縮有りを示す。

下位ビットから上位ビットの順で圧縮データ列と対応する。

下位からの各ビットと圧縮データ列への対応を次の表に示す。

表2. 圧縮フラグと圧縮データの対応
| bit | 詳細 |
|-|-|
| 1(下位)   | 圧縮データ列の1番目に対するフラグ。 |
| 2 | 圧縮データ列の2番目に対するフラグ。 |
| 3 | 圧縮データ列の3番目に対するフラグ。 |
| 4 | 圧縮データ列の4番目に対するフラグ。 |
| 5 | 圧縮データ列の5番目に対するフラグ。 |
| 6 | 圧縮データ列の6番目に対するフラグ。 |
| 7 | 圧縮データ列の7番目に対するフラグ。 |
| 8(上位ビット)   | 圧縮データ列の8番目に対するフラグ。 |

# 圧縮データ列
圧縮データの配列で構成される。

## 圧縮データ
データサイズは、圧縮フラグによって変化する。
圧縮フラグが圧縮無しの場合に1バイト、圧縮有りの場合に2バイトを示す。

## 圧縮無し
1バイト。対象の圧縮データは展開後のバイト列に出力される。

## 圧縮有り
2バイト。対象の圧縮データは展開後のバイト列に出力されず、「長さ」と「参照位置との差」としてそれぞれ扱う必要がある。

長さとは、コピーするバイト列の長さを示す。

参照位置との差は、展開中のバイト列における末尾を起点に、"いくつ前の位置を参照位置としてバイト列からコピーをするか"を示す。

このバイト列のみビッグエンディアンである。

従い1バイト目の値は左に8ビット左シフトした上で2バイト目と加算した上で「長さ」と「参照位置との差」を抽出する必要がある。

「長さ」として扱うビット数は、2バイトの内の上位(0x10 - 辞書サイズ指数)ビット。

「参照位置との差」として扱うビット数は、下位(辞書サイズ指数)ビットが示す。

辞書サイズ指数に対する「長さ」と「参照位置との差」として扱うビット数の対応を以下に示す。

表2. 辞書サイズ指数に対する「長さ」と「参照位置との差」として扱うビット数の対応
| 辞書サイズ指数 | 長さ(ビット) | 参照位置との差(ビット) |
|-|-|-|
| 0x0C | 0x04 | 0x0C |
| 0x0B | 0x05 | 0x0B |
| 0x0A | 0x06 | 0x0A |
| 0x09 | 0x07 | 0x09 |

## 「長さ」や「参照位置との差」が0の場合

以下の通り最大値であることを示している。

長さ が0の場合、`2 ^ (0x10 - 辞書サイズ指数)`であることを示す。

参照位置との差 が0の場合、`2 ^ (辞書サイズ指数)`であることを示す。

### 例1.

辞書サイズ指数指数: 0x0C

圧縮データ: 0x0000
(長さ: 0x0, 参照位置との差: 0x000)

展開中バイト列末尾の位置: 0x3000

上記の場合、長さは0x10[^2]、参照位置との差は0x1000[^3]ということになる。

従い、参照位置を0x2000として、参照位置から0x10バイトをコピーすることを示す。

[^2]: 辞書サイズ指数が0x0Cであることから、`2 ^ (0x10 - 0xC) = 0x10`のため。

[^3]: 辞書参照指数が0x0Cであることから、`2 ^ 0x0C = 0x1000`のため。


## "参照位置との差"より"長さ"が大きい
展開中バイト列にて"参照位置との差"で戻った分よりもコピーするバイト列の"長さ"が大きく、展開中バイト列の末尾を超える場合がある。

この場合、コピー対象のバイト列を繰り返しコピーする必要がある。

### 例2.

辞書サイズ指数: 0x0C

圧縮データ: 0x5002 (長さ: 0x5, 参照位置との差: 0x02)

展開中バイト列は以下。

表3. 展開中バイト列
| index | [1] | [2] | [3] | [4] |
|-|-|-|-|-|
| 参照位置との差 | 4 | 3 | 2 | 1 |
| data(Hex) | 11  | 22  | 33  | 44  |

展開後のデータは"参照位置との差"が2(index[3])を"参照位置"として0x5バイト分をコピーすることを示す。

展開後のバイト列は以下である。

表4. 展開後のバイト列

| index | [1] | [2] | [3] | [4] | [5] | [6] | [7] | [8] | [9] |
|-|-|-|-|-|-|-|-|-|-|
| 参照位置との差 | 4 | 3 | 2 | 1|  |  |  |  |  |
| data(Hex) | 11  | 22  | 33  | 44  | 33  | 44  | 33  | 44  | 33  |


展開中バイト列(表3)における"参照位置の差"が2とはindex[3]を指す。
ここから0x5バイト分コピーを試みるとindex[3]、index[4]の2バイトはコピーが可能である。

しかし残りの3バイトが足りないのである。

この足りない分は、index[3]、index[4]、index[3]とコピー可能な部分を繰り返して埋める必要がある。