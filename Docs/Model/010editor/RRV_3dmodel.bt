//------------------------------------------------
//--- 010 Editor v13.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef struct {
    short coord[3];
    short normal[3];
    short uv[2];
} VertexType1;

typedef struct {
    short coord[3];
    short uv[2];
} VertexType2;

typedef struct  {
    uint unk0x00;
    uint unk0x04;
    uint unk0x08;
    uint unk0x0C;
    short vertex_length;
    short unk0x12;
    uint unk0x14;
    uint unk0x18;
    short unk0x1C;
    ubyte unk0x1E;
    ubyte unk0x1F;
} VetexHeader;

typedef struct(uint end_adr) {
    struct SurfaceHeader {
        uint unk0x00;
        uint unk0x04;
        uint unk0x08;
        short unk0x0C;
        short submesh_length;
    } surface_header;
    
    if ( surface_header.unk0x00 == 0 && surface_header.submesh_length == 0 ) {
        return;
    }
   if (end_adr == 0) {
        end_adr = FTell() + (surface_header.submesh_length-1) * 0x10;
    }

    VetexHeader vertex_header;
    local int i = 0;
    local int vertex_lenght = vertex_header.vertex_length & 0x7FFF;
    for (i = 0; i < vertex_lenght; i++) {
        if (FTell() >= end_adr) {
            break;
        }
        switch (vertex_header.unk0x1F) {
            case 0x0:
                FSeek(end_adr);
                break;
            case 0x1:
            case 0xF:
                VertexType2 vertex;
                break;
            default:
                VertexType1 vertex;
                break;
        }
    }
    while ( (FTell() % 0x10) > 0 ) {
        FSeek(FTell() + 1);
   }
} Surface;

typedef struct {
    local uint end_adr = FTell();
    Surface surface(0);
    end_adr += surface.surface_header.submesh_length * 0x10;
    while (FTell() < end_adr) {
        Surface surface(end_adr);
    }
} Submesh;

typedef struct (uint mesh_end_adr) {
//    Printf("mesh_end_adr: %x \r\n", mesh_end_adr);
    while (FTell() < mesh_end_adr) {
        Submesh submesh;
    }
} Mesh;

typedef struct {
    uint object_ptr;
    uint texture_ptr;
} Entry;

typedef struct {
    int object_count;
    Entry entry[object_count];
} Header;


// main
LittleEndian();

Header header;
local uint mesh_end_adr;
local int i = 0;
for (i = 0; i < header.object_count; i++) {
    FSeek(header.entry[i].object_ptr);
    if (i >= header.object_count-1) {
        mesh_end_adr = FileSize();
    } else {
        mesh_end_adr = header.entry[i+1].object_ptr;
    }
    Mesh mesh(mesh_end_adr);
}